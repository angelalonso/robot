#include <functional>
#include <future>
#include <memory>
#include <string>
#include <sstream>

#include "action_interfaces/action/led.hpp"

#include "rclcpp/rclcpp.hpp"
#include "rclcpp_action/rclcpp_action.hpp"
#include "rclcpp_components/register_node_macro.hpp"


namespace circuit_nodes {

  class MasterNode : public rclcpp::Node {
    //auto actionClient = rclcpp_action::create_client<action_interfaces::action::Led>(this, "led");
    public:
      static rclcpp_action::Client<action_interfaces::action::Led>::SharedPtr actionClient;
      MasterNode() : Node("master_node") {
        //auto MasterNode::actionClient = rclcpp_action::create_client<action_interfaces::action::Led>(this, "led");
        MasterNode::actionClient = rclcpp_action::create_client<action_interfaces::action::Led>(this, "led");

        // waiting for the server online response
        if (!actionClient->wait_for_action_server(std::chrono::seconds(10)))
        {
          RCLCPP_ERROR(this->get_logger(), "!!ATTENTION!! Action server not available");
//          return 1; // not in a constructor!
        }

        timer_ = this->create_wall_timer(
          std::chrono::milliseconds(200),
          std::bind(&MasterNode::timerCallback, this)
        );
      }
  
    void FeedbackCallback(
      rclcpp_action::ClientGoalHandle<action_interfaces::action::Led>::SharedPtr,
      const std::shared_ptr<const action_interfaces::action::Led::Feedback> feedback,
      rclcpp::Logger logger)
    {
      RCLCPP_INFO(logger,
        "Feedback received: %s",
        feedback->process_feed.c_str());
    }


  private:

    void timerCallback() {
      RCLCPP_INFO(this->get_logger(), "Hello from ROS2");
      //led->send_goal();
      //
      // creation of the goal message
      auto goalMsg = action_interfaces::action::Led::Goal();
      goalMsg.turn_on = false;  // the number of concatenation to perform

      RCLCPP_INFO(this->get_logger(), "Sending goal");
      auto send_goal_options = rclcpp_action::Client<action_interfaces::action::Led>::SendGoalOptions();
      send_goal_options.feedback_callback = std::bind(&MasterNode::FeedbackCallback, this, std::placeholders::_1, std::placeholders::_2);
      send_goal_options.result_callback = std::bind(&MasterNode::ResultCallback, this, std::placeholders::_1);
      send_goal_options.goal_response_callback = std::bind(&MasterNode::GoalResponseCallback, this, std::placeholders::_1);
      auto goal_handle_future = this->clientPtr_->async_send_goal(goalMsg, send_goal_options);
    }
    rclcpp::TimerBase::SharedPtr timer_;


    void FeedbackCallback(
      rclcpp_action::ClientGoalHandle<action_interfaces::action::Led>::SharedPtr,
      const std::shared_ptr<const action_interfaces::action::Led::Feedback> feedback)
    {
      RCLCPP_INFO(this->get_logger(),
        "Feedback received: %s",
        feedback->process_feed.c_str());
    }


    void ResultCallback(const GoalHandleLed::WrappedResult& result)
    {
      this->goalDone_ = true;
      switch (result.code) {
        case rclcpp_action::ResultCode::SUCCEEDED:
          break;
        case rclcpp_action::ResultCode::ABORTED:
          RCLCPP_ERROR(this->get_logger(), "Goal was aborted");
          return;
        case rclcpp_action::ResultCode::CANCELED:
          RCLCPP_ERROR(this->get_logger(), "Goal was canceled");
          return;
        default:
          RCLCPP_ERROR(this->get_logger(), "Unknown result code");
          return;
      }

      RCLCPP_INFO(this->get_logger(), "Result received");
      for (auto number : result.result->confirmed)
      {
        RCLCPP_INFO(this->get_logger(), "%d", number);
      }
    }

    // defining the parameter directly as a GoalHandleLed::SharedPtr goalHandle
    // it's wrong for the send_goal_options.goal_response_callback
    // so it doesnt compile
    void GoalResponseCallback(
      std::shared_future<GoalHandleLed::SharedPtr> future)
      {
        auto goalHandle = std::future.get();
        if (!goalHandle)
        {
          RCLCPP_ERROR(this->get_logger(), "Goal was rejected by server");
        } else
        {
          RCLCPP_INFO(this->get_logger(), "Goal accepted by server, waiting for result");
        }
      }
  };

}  // namespace circuit_nodes

int main(int argc, char * argv[]) {
  rclcpp::init(argc, argv);
  auto node = std::make_shared<circuit_nodes::MasterNode>();
  rclcpp::spin(node);
  rclcpp::shutdown();
  return 0;
}
